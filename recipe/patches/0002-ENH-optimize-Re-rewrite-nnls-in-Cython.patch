From 8d0d978eefb8d4be10681c83f566f2a73d6acec3 Mon Sep 17 00:00:00 2001
From: Ilhan Polat <ilhanpolat@gmail.com>
Date: Sat, 22 Jun 2024 01:25:43 +0200
Subject: [PATCH 2/2] ENH:optimize: Re-rewrite nnls in Cython

---
 scipy/optimize/_cython_nnls.pyx   | 216 ++++++++++++++++++++++++++++++
 scipy/optimize/_nnls.py           |  83 ++----------
 scipy/optimize/meson.build        |   9 ++
 scipy/optimize/tests/test_nnls.py | 113 +++++++++++++++-
 4 files changed, 345 insertions(+), 76 deletions(-)
 create mode 100644 scipy/optimize/_cython_nnls.pyx

diff --git a/scipy/optimize/_cython_nnls.pyx b/scipy/optimize/_cython_nnls.pyx
new file mode 100644
index 0000000000..53bfb82adf
--- /dev/null
+++ b/scipy/optimize/_cython_nnls.pyx
@@ -0,0 +1,216 @@
+# cython: boundscheck=False
+# cython: initializedcheck=False
+# cython: wraparound=False
+# cython: cdivision=True
+# cython: cpow=True
+
+
+__all__ = ['_nnls']
+
+from scipy.linalg.cython_lapack cimport dlarfgp, dlarf, dlartgp
+from scipy.linalg.cython_blas cimport dnrm2
+import numpy as np
+cimport numpy as cnp
+cnp.import_array()
+
+def _nnls(cnp.ndarray[cnp.float64_t, ndim=2] A_in,
+          cnp.ndarray[cnp.float64_t, ndim=1] b_in,
+          int maxiter):
+    # Make copies of the input to be mutated
+    cdef cnp.ndarray[cnp.float64_t, ndim=2, mode='c'] A = A_in.copy(order='C')
+    cdef cnp.ndarray[cnp.float64_t, ndim=1, mode='c'] b = b_in.copy()
+
+    cdef int m = <int>A.shape[0], n = <int>A.shape[1]
+    cdef int i = 0, ii = 0, ip = 0, iteration = 0, iz = 0, iz1 = 0, izmax = 0
+    cdef int j = 0, jj = 0, k = 0
+    cdef int col = 0, nrow = 0, nsetp = 0, one = 1, tmpint = 0
+    cdef double tau = 0.0, unorm = 0.0, ztest, tmp, alpha, beta, cc, ss, wmax, T
+    cdef cnp.ndarray[cnp.float64_t, ndim=1, mode='c'] w
+    cdef cnp.ndarray[cnp.float64_t, ndim=1, mode='c'] x
+    cdef cnp.ndarray[cnp.float64_t, ndim=1, mode='c'] work
+    cdef cnp.ndarray[cnp.float64_t, ndim=1, mode='c'] zz
+    cdef cnp.ndarray[cnp.int32_t, ndim=1, mode='c'] inds
+    cdef bint skip = False
+
+    inds = cnp.PyArray_Arange(0, n, 1, cnp.NPY_INT32)
+    w = cnp.PyArray_EMPTY(1, [n], cnp.NPY_FLOAT64, 0)
+    work = cnp.PyArray_EMPTY(1, [m], cnp.NPY_FLOAT64, 0)
+    x = cnp.PyArray_ZEROS(1, [n], cnp.NPY_FLOAT64, 0)
+    zz = cnp.PyArray_EMPTY(1, [m], cnp.NPY_FLOAT64, 0)
+
+    # Quit if all coefficients are already in the solution or if m columns of A
+    # have been triangularized.
+    while (iz1 < n) and (nsetp < m):
+        # simulating a goto from col independence check
+        if skip:
+            skip = False
+        else:
+            w[inds[iz1:]] = b[nrow:] @ A[nrow:, inds[iz1:]]
+
+        # Find the largest w[j] and its index.
+        wmax = 0.0
+        for col in range(iz1, n):
+            j = inds[col]
+            if w[j] > wmax:
+                wmax = w[j]
+                izmax = col
+        iz = izmax
+        j = inds[iz]
+
+        # If wmax <= 0.0, terminate since this is a KKT certificate.
+        if wmax <= 0.0:
+            break
+
+        # The sign of wmax is OK for j to be moved to set p. Begin the transformation
+        # and check new diagonal element to avoid near-linear dependence.
+        work[nrow:] = A[nrow:, j]
+        tmpint = m - nrow
+        # DLARFGP( N, ALPHA, X, INCX, TAU )
+        dlarfgp(&tmpint, &work[nrow], &work[nrow+1], &one, &tau)
+        beta = work[nrow]
+        work[nrow] = 1.
+        unorm = 0.0
+        if nsetp > 0:
+            unorm = dnrm2(&nsetp, &A[0, j], &n)
+
+        if ((unorm + abs(beta)*0.01) - unorm) > 0.0:
+            # Column j is sufficiently independent. Copy b into zz and solve for
+            # ztest which is the new prospective value for x[j].
+            zz[:] = b[:]
+            # dlarf(SIDE, M, N, V, INCV, TAU, C, LDC, WORK)
+            dlarf(<char*>'L', &tmpint, &one, &work[nrow], &one, &tau,
+                  &zz[nrow], &tmpint, &tmp)
+            ztest = zz[nrow] / beta
+
+            if ztest <= 0.0:
+                # reject column j as a candidate to be moved from set z to set p.
+                # Set w[j] to 0.0 and move to the next greatest entry in w.
+                w[j] = 0.0
+                skip = True
+                continue
+        else:
+            # Column j is not numerically independent, reject column j
+            w[j] = 0.0
+            skip = True
+            continue
+
+        # column j accepted
+        A[nrow, j] = beta
+        b[:] = zz[:]
+        inds[iz] = inds[iz1]
+        inds[iz1] = j
+        iz1 += 1
+        nsetp += 1
+
+        if iz1 < n:
+            # Apply the householder trafo to remaining columns
+            for col in inds[iz1:]:
+                zz[nrow:] = A[nrow:, col]
+                dlarf(<char*>'L', &tmpint, &one, &work[nrow], &one, &tau,
+                      &zz[nrow], &tmpint, &tmp)
+                A[nrow:, col] = zz[nrow:]
+
+        nrow += 1
+
+        if nsetp < m-1:
+            A[nrow:, j] = 0.0
+
+        w[j] = 0.0
+
+        # Solve triangular system, store in zz
+        zz[:] = b[:]
+        for k in range(nsetp):
+            ip = nsetp - k - 1
+            if k != 0:
+                for ii in range(ip+1):
+                    zz[ii] -= A[ii, jj]*zz[ip+1]
+            jj = inds[ip]
+            zz[ip] /= A[ip, jj]
+
+        # Inner loop
+        while True:
+            iteration += 1
+
+            if iteration == maxiter:
+                return x, 0.0, -1
+
+            # See if all new constrained coefficients are feasible
+            # otherwise compute alpha that should be in [0, 1]
+            alpha = 2.0
+            for ip in range(nsetp):
+                k = inds[ip]
+                if zz[ip] <= 0.0:
+                    T = -x[k] / (zz[ip]-x[k])
+                    if alpha > T:
+                        alpha = T
+                        jj = ip
+
+            # If all new constrained coefficients are feasible
+            # alpha is still 2 then exit otherwise interpolate
+            # between old x and zz.
+            if alpha == 2.0:
+                break
+
+            x[inds[:nsetp]] *= 1 - alpha
+            x[inds[:nsetp]] += alpha*zz[:nsetp]
+
+            # Modify A, B, and the indices to move coefficient
+            # i from set p to set z. While loop simulates a goto
+            i = inds[jj]
+            while True:
+                x[i] = 0.0
+
+                if jj != nsetp:
+                    jj += 1
+                    for j in range(jj, nsetp):
+                        ii = inds[j]
+                        inds[j-1] = ii
+                        dlartgp(&A[j-1, ii], &A[j, ii], &cc, &ss, &A[j-1, ii])
+                        A[j, ii] = 0.0
+                        # Apply Givens rotation to all cols except ii
+                        for col in range(n):
+                            if col != ii:
+                                tmp = A[j-1, col]
+                                A[j-1, col] = cc*tmp + ss*A[j, col]
+                                A[j, col] = -ss*tmp + cc*A[j, col]
+
+                        tmp = b[j-1]
+                        b[j-1] = cc*tmp + ss*b[j]
+                        b[j] = -ss*tmp + cc*b[j]
+
+                nrow -= 1
+                nsetp -= 1
+                iz1 -= 1
+                inds[iz1] = i
+
+                # See if remaining coefficients in set P are feasible
+                # since determination of alpha guarantees it. If still
+                # there are infeasible ones, they are due to numerical
+                # noise. Any that are nonpositive will be set to zero
+                # and moved from set p to set z.
+                for jj in range(nsetp):
+                    i = inds[jj]
+                    if x[i] <= 0.0:
+                        # numerical noise; back to top of while loop
+                        break
+                else:
+                    # No break; leave while loop
+                    break
+
+            zz[:] = b[:]
+            for k in range(nsetp):
+                ip = nsetp - k - 1
+                if k != 0:
+                    for ii in range(ip+1):
+                        zz[ii] -= A[ii, jj]*zz[ip+1]
+                jj = inds[ip]
+                zz[ip] /= A[ip, jj]
+
+            # Back to inner loop beginning
+
+        # Back in outer loop
+        x[inds[:nsetp]] = zz[:nsetp]
+
+        # Back to the outer loop beginning
+
+    return x, np.linalg.norm(b[nrow:]), 0
diff --git a/scipy/optimize/_nnls.py b/scipy/optimize/_nnls.py
index 17fcdc9e4c..be904c90d7 100644
--- a/scipy/optimize/_nnls.py
+++ b/scipy/optimize/_nnls.py
@@ -1,6 +1,6 @@
 import numpy as np
-from scipy.linalg import solve, LinAlgWarning
-import warnings
+from ._cython_nnls import _nnls
+
 
 __all__ = ['nnls']
 
@@ -71,8 +71,8 @@ def nnls(A, b, maxiter=None, *, atol=None):
 
     """
 
-    A = np.asarray_chkfinite(A)
-    b = np.asarray_chkfinite(b)
+    A = np.asarray_chkfinite(A, dtype=np.float64, order='C')
+    b = np.asarray_chkfinite(b, dtype=np.float64)
 
     if len(A.shape) != 2:
         raise ValueError("Expected a two-dimensional array (matrix)" +
@@ -88,77 +88,10 @@ def nnls(A, b, maxiter=None, *, atol=None):
                 "Incompatible dimensions. The first dimension of " +
                 f"A is {m}, while the shape of b is {(b.shape[0], )}")
 
-    x, rnorm, mode = _nnls(A, b, maxiter, tol=atol)
-    if mode != 1:
+    if not maxiter:
+        maxiter = 3*n
+    x, rnorm, info = _nnls(A, b, maxiter)
+    if info == -1:
         raise RuntimeError("Maximum number of iterations reached.")
 
     return x, rnorm
-
-
-def _nnls(A, b, maxiter=None, tol=None):
-    """
-    This is a single RHS algorithm from ref [2] above. For multiple RHS
-    support, the algorithm is given in  :doi:`10.1002/cem.889`
-    """
-    m, n = A.shape
-
-    AtA = A.T @ A
-    Atb = b @ A  # Result is 1D - let NumPy figure it out
-
-    if not maxiter:
-        maxiter = 3*n
-    if tol is None:
-        tol = 10 * max(m, n) * np.spacing(1.)
-
-    # Initialize vars
-    x = np.zeros(n, dtype=np.float64)
-    s = np.zeros(n, dtype=np.float64)
-    # Inactive constraint switches
-    P = np.zeros(n, dtype=bool)
-
-    # Projected residual
-    w = Atb.copy().astype(np.float64)  # x=0. Skip (-AtA @ x) term
-
-    # Overall iteration counter
-    # Outer loop is not counted, inner iter is counted across outer spins
-    iter = 0
-
-    while (not P.all()) and (w[~P] > tol).any():  # B
-        # Get the "most" active coeff index and move to inactive set
-        k = np.argmax(w * (~P))  # B.2
-        P[k] = True  # B.3
-
-        # Iteration solution
-        s[:] = 0.
-        # B.4
-        with warnings.catch_warnings():
-            warnings.filterwarnings('ignore', message='Ill-conditioned matrix',
-                                    category=LinAlgWarning)
-            s[P] = solve(AtA[np.ix_(P, P)], Atb[P], assume_a='sym', check_finite=False)
-
-        # Inner loop
-        while (iter < maxiter) and (s[P].min() < 0):  # C.1
-            iter += 1
-            inds = P * (s < 0)
-            alpha = (x[inds] / (x[inds] - s[inds])).min()  # C.2
-            x *= (1 - alpha)
-            x += alpha*s
-            P[x <= tol] = False
-            with warnings.catch_warnings():
-                warnings.filterwarnings('ignore', message='Ill-conditioned matrix',
-                                        category=LinAlgWarning)
-                s[P] = solve(AtA[np.ix_(P, P)], Atb[P], assume_a='sym',
-                             check_finite=False)
-            s[~P] = 0  # C.6
-
-        x[:] = s[:]
-        w[:] = Atb - AtA @ x
-
-        if iter == maxiter:
-            # Typically following line should return
-            # return x, np.linalg.norm(A@x - b), -1
-            # however at the top level, -1 raises an exception wasting norm
-            # Instead return dummy number 0.
-            return x, 0., -1
-
-    return x, np.linalg.norm(A@x - b), 1
diff --git a/scipy/optimize/meson.build b/scipy/optimize/meson.build
index d6c20d3d53..c7fe69a38b 100644
--- a/scipy/optimize/meson.build
+++ b/scipy/optimize/meson.build
@@ -203,6 +203,15 @@ py3.extension_module('_bglu_dense',
   subdir: 'scipy/optimize'
 )
 
+py3.extension_module('_cython_nnls',
+  opt_gen.process('_cython_nnls.pyx'),
+  c_args: cython_c_args,
+  dependencies: np_dep,
+  link_args: version_link_args,
+  install: true,
+  subdir: 'scipy/optimize'
+)
+
 subdir('_lsq')
 subdir('_trlib')
 subdir('_trustregion_constr')
diff --git a/scipy/optimize/tests/test_nnls.py b/scipy/optimize/tests/test_nnls.py
index aa4956febd..67443dd614 100644
--- a/scipy/optimize/tests/test_nnls.py
+++ b/scipy/optimize/tests/test_nnls.py
@@ -97,7 +97,7 @@ class TestNNLS:
 
         # Small perturbations can already make the infinite loop go away (just
         # uncomment the next line)
-        k = k + 1e-10 * np.random.normal(size=N)
+        # k = k + 1e-10 * np.random.normal(size=N)
         dact, _ = nnls(W @ A, W @ k)
         assert_allclose(dact, d, rtol=0., atol=1e-10)
 
@@ -316,3 +316,114 @@ class TestNNLS:
         sol, rnorm = nnls(A, b)
         assert_allclose(sol, np.array([0.61124315, 8.22262829, 0., 0., 0.]))
         assert_allclose(rnorm, 1.0556460808977297)
+
+    def test_nnls_gh21021_ex1(self):
+        # Review examples used in gh-21021
+        A = [[0.004734199143798789, -0.09661916455815653, -0.04308779048103441,
+             0.4039475561867938, -0.27742598780954364, -0.20816924034369574,
+             -0.17264070902176, 0.05251808558963846],
+             [-0.030263548855047975, -0.30356483926431466, 0.18080406600591398,
+              -0.06892233941254086, -0.41837298885432317, 0.30245352819647003,
+              -0.19008975278116397, -0.00990809825429995],
+             [-0.2561747595787612, -0.04376282125249583, 0.4422181991706678,
+              -0.13720906318924858, -0.0069523811763796475, -0.059238287107464795,
+              0.028663214369642594, 0.5415531284893763],
+             [0.2949336072968401, 0.33997647534935094, 0.38441519339815755,
+              -0.306001783010386, 0.18120773805949028, -0.36669767490747895,
+              -0.021539960590992304, -0.2784251712424615],
+             [0.5009075736232653, -0.20161970347571165, 0.08404512586550646,
+              0.2520496489348788, 0.14812015101612894, -0.25823455803981266,
+              -0.1596872058396596, 0.5960141613922691]
+             ]
+        b = [18.036779281222124, -18.126530733870887, 13.535652034584029,
+             -2.6654275476795966, 9.166315328199575]
+
+        # Obtained from matlab's lstnonneg
+        des_sol = np.array([0., 118.017802006619, 45.1996532316584, 102.62156313537,
+                            0., 55.8590204314398, 0., 29.7328833253434])
+        sol, res = nnls(A, b)
+        assert_allclose(sol, des_sol)
+        assert np.abs(np.linalg.norm(A@sol - b) - res) < 5e-14
+
+    def test_nnls_gh21021_ex2(self):
+        A = np.array([
+            [0.2508259992635229, -0.24031300195203256],
+            [0.510647748500133, 0.2872936081767836],
+            [0.8196387904102849, -0.03520620107046682],
+            [0.030739759120097084, -0.07768656359879388]])
+        b = np.array([24.456141951303913,
+                      28.047143273432333,
+                      41.10526799545987,
+                      -1.2078282698324068])
+
+        sol, res = nnls(A, b)
+        assert_allclose(sol, np.array([54.3047953202271, 0.0]))
+        assert np.abs(np.linalg.norm(A@sol - b) - res) < 5e-14
+
+    def test_nnls_gh21021_ex3(self):
+        A = np.array([
+            [0.08247592017366788, 0.058398241636675674, -0.1031496693415968,
+             0.03156983127072098, -0.029503680182026665],
+            [0.21463607509982277, -0.2164518969308173, -0.10816833396662294,
+             0.12133867146012027, -0.15025010408668332],
+            [0.07251900316494089, -0.003044559315020767, 0.042682817961676424,
+             -0.018157525489298176, 0.11561953260568134],
+            [0.2328797918159187, -0.09112909645892767, 0.21348169727099078,
+             0.00449447624089599, -0.16615256386885716],
+            [-0.02440856024843897, -0.20131427208575386, 0.030275781997161483,
+             -0.04560777213546784, 0.11007266012013553],
+            [-0.2928391429686263, -0.20437574856615687, -0.020892110811574407,
+             -0.10455040720819309, 0.05337267000160461],
+            [0.22041503019400316, 0.014262782992311842, 0.08274606359871121,
+             -0.17933172096518907, -0.11809690350702161],
+            [0.10440436007469953, 0.09171452270577712, 0.03942347724809893,
+             0.11457669688231396, 0.07529747295631585],
+            [-0.052087576116032056, -0.15787717158077047, -0.08232202515883282,
+             -0.03194837933710708, -0.0546812506025729],
+            [-0.010388407673304468, 0.015174707581808923, 0.04764509565386281,
+             -0.1781221936030805, 0.10218894080536609],
+            [0.03272263140115928, -0.27576456949442574, 0.024897570959901753,
+             -0.1417129166632282, -0.03320796462136591],
+            [-0.12490006751823997, -0.03012003515442302, -0.051495264012509506,
+             0.012070729698374614, 0.04811700123118234],
+            [0.15254854117990788, -0.051863547789218374, 0.058012914127346174,
+             -0.06717991061422621, -0.14514671564242257],
+            [0.12251250415395559, -0.17462495626695362, -0.025334728552179834,
+             0.11425350676877533, 0.06183915953812639],
+            [0.19334259720491218, 0.2164301986218955, -0.018882278726614483,
+             0.07950236716817938, -0.2220529357431092],
+            [-0.01822205701890852, 0.12630444976752267, -0.03118092027244001,
+             0.02773743885242581, 0.06444433740044248],
+            [0.13344116850581977, -0.05142877469996826, 0.3385702016705455,
+             -0.25814970787123004, 0.2679034842977378],
+            [0.1309747058619377, 0.12090608957940627, -0.13957978654106512,
+             0.17048819760322642, -0.241775259969348],
+            [0.28613102173467275, -0.47153463906732174, 0.20359970518269746,
+             -0.0962095202871843, -0.07703076550836387],
+            [0.2212788380372723, 0.02569245145758152, -0.021596152392209966,
+             0.04610005150029433, -0.2024454395619734],
+            [-0.043225338359410316, 0.17816095186290315, -0.014709092962616079,
+             0.06993970293287989, -0.09033722782555903],
+            [0.17747622942563512, -0.20991014784011458, 0.06265720409894943,
+             0.0689704059061795, 0.024474319398401525],
+            [-0.1163880385601698, 0.29989570587630027, 0.033443765320984545,
+             0.008470296514656, -0.0014457113271462002],
+            [0.024375314902718406, 0.05279830705548363, 0.02691082431023144,
+             0.05265079368002343, 0.15542988147487913],
+            [-0.01855218360922308, -0.050265869142888164, 0.2567912677240452,
+             -0.2606428528561333, 0.25334396245022245]])
+
+        b = np.array([-7.876625373734849, -8.259856278691373, 3.2593082374900963,
+                      16.30170376973345, 2.311892943629045, -1.595345202555738,
+                      6.318582970536518, 3.0104212955340093, -6.286202915842167,
+                      3.6382333725029294, 1.9012066681249356, -3.932236581436514,
+                      4.4299317131740406, -1.9345885161292682, -1.4418721521970805,
+                      -2.3810103256943926, 25.853603392922526, -10.658470311610483,
+                      15.547103681119214, -1.6491066136547277, -1.1232029689817422,
+                      4.7845749463206975, 2.553803732013229, 2.0549409701753705,
+                      19.60887153608244])
+
+        sol, res = nnls(A, b)
+        assert_allclose(sol, np.array([0.0, 0.0, 76.3611306173957, 0.0, 0.0]),
+                        atol=5e-14)
+        assert np.abs(np.linalg.norm(A@sol - b) - res) < 5e-14
